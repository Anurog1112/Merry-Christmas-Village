<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Merry Christmas Village</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Three.js OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Font -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&family=Mountains+of+Christmas:wght@400;700&family=Mali:wght@400;600;700&family=Itim&display=swap" rel="stylesheet">
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Mali', cursive;
            /* Magical Night Sky Gradient - Darker & Deeper */
            background: radial-gradient(circle at 50% 0%, #1e1b4b 0%, #0f172a 40%, #000000 100%);
        }

        h1, h2, .header-text, .thought-bubble, #click-hint {
            font-family: 'Mountains of Christmas', cursive;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        .header-container {
            position: absolute; top: 5%; width: 100%; text-align: center;
            pointer-events: auto; z-index: 20;
        }

        .header-text {
            font-family: 'Mountains of Christmas', cursive;
            font-size: 4.5rem; font-weight: 700;
            background: linear-gradient(to bottom, #FFF8DC 0%, #FFD700 30%, #DAA520 60%, #8B4513 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8));
            animation: floatText 3s ease-in-out infinite; display: inline-block; margin: 0 10px; letter-spacing: 2px;
        }

        .header-decor {
            font-size: 2.5rem; display: inline-block; vertical-align: middle;
            animation: bounce 2s infinite; filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
        }

        .header-sub {
            color: #fef3c7; font-size: 1.2rem; margin-top: -5px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8); letter-spacing: 1px;
        }

        @keyframes floatText {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-5px) scale(1.02); }
        }

        #music-btn {
            position: absolute; top: 20px; right: 20px;
            background: linear-gradient(45deg, #d97706, #fbbf24); border: 2px solid #fffbeb;
            color: #fff; padding: 10px 20px; border-radius: 50px; cursor: pointer;
            pointer-events: auto; transition: all 0.3s; z-index: 50; display: flex; align-items: center;
            gap: 8px; font-weight: bold; box-shadow: 0 4px 15px rgba(251, 191, 36, 0.4);
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        #music-btn:hover { transform: scale(1.05); filter: brightness(1.1); }

        #youtube-player { position: absolute; top: -1000px; left: -1000px; opacity: 0; pointer-events: none; }

        #click-hint {
            position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%);
            color: #bae6fd; font-size: 1.5rem; text-shadow: 0 0 10px rgba(186, 230, 253, 0.8);
            font-family: 'Mountains of Christmas', cursive; font-weight: 700;
            animation: bounce 1.5s infinite; pointer-events: none;
            background: rgba(15, 23, 42, 0.6); padding: 8px 25px;
            border-radius: 20px; backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,0.1);
        }
        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
        }

        .thought-bubble {
            position: absolute; background: white; color: #333;
            padding: 15px 25px; border-radius: 20px; font-weight: bold; font-size: 1.4rem;
            font-family: 'Mountains of Christmas', cursive;
            opacity: 0; transform: translate(-50%, -100%) scale(0.5);
            transition: opacity 0.4s, transform 0.4s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2); white-space: nowrap;
            pointer-events: auto; cursor: pointer; z-index: 20;
        }
        .thought-bubble::after {
            content: ''; position: absolute; bottom: -10px; left: 50%;
            transform: translateX(-50%); border-width: 10px 10px 0;
            border-style: solid; border-color: white transparent; display: block; width: 0;
        }

        #wish-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(2, 6, 23, 0.85); display: flex;
            justify-content: center; align-items: center; z-index: 100;
            opacity: 0; pointer-events: none; transition: opacity 0.5s;
            backdrop-filter: blur(8px);
        }
        .visible-el { opacity: 1 !important; pointer-events: auto !important; }
        
        #wish-card {
            /* Simple Clean Design */
            background-color: #fffbeb;
            width: 85%; max-width: 500px; padding: 40px 30px;
            border-radius: 15px;
            text-align: center; color: #451a03;
            
            /* 3D Perspective & Floating Animation */
            transform: perspective(1000px) rotateX(5deg) rotateY(0deg) scale(0.85);
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.5s;
            animation: floatCard 4s ease-in-out infinite;
            
            /* Simple Border */
            border: 4px solid #b45309;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            
            font-family: 'Itim', cursive;
            position: relative;
        }

        /* Removed hanging decorations for simplicity */
        #wish-card::before { content: none; }
        #wish-card::after { content: none; }

        @keyframes floatCard {
            0%, 100% { transform: perspective(1000px) rotateX(5deg) translateY(0); }
            50% { transform: perspective(1000px) rotateX(5deg) translateY(-8px); }
        }

        .scale-in { 
            transform: perspective(1000px) rotateX(0deg) rotateY(0deg) scale(0.95) !important; 
            animation: none !important;
        }

        .btn-close {
            background: #ef4444;
            color: white; border: none;
            padding: 12px 25px;
            width: auto; height: auto;
            border-radius: 30px;
            display: inline-block;
            font-size: 1.2rem; cursor: pointer;
            transition: all 0.3s; font-family: 'Itim', cursive;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            margin: 20px auto 0;
            position: relative;
        }
        .btn-close::after { content: none; }
        .btn-close:hover { transform: scale(1.05); background: #dc2626; box-shadow: 0 6px 10px rgba(0,0,0,0.3); }
        
        #wish-text {
            font-size: 1.6rem; line-height: 1.6; margin-bottom: 20px; color: #451a03;
            font-family: 'Itim', cursive;
            background: transparent;
            padding: 0; border-radius: 0;
        }
        #wish-text::first-letter {
            font-size: 1.6rem; float: none; color: inherit; font-family: inherit;
        }
        
        #wish-card h2 {
            font-family: 'Itim', cursive;
            font-size: 2.2rem;
            color: #b45309;
            margin-bottom: 15px;
            text-shadow: none;
        }

        .ui-particle {
            position: absolute;
            width: 5px; height: 5px;
            background: gold;
            border-radius: 50%;
            pointer-events: none;
            animation: fadeOutDrop 1s forwards;
            box-shadow: 0 0 5px gold;
        }
        @keyframes fadeOutDrop {
            0% { opacity: 1; transform: translate(0, 0) scale(1); }
            100% { opacity: 0; transform: translate(var(--tx), var(--ty)) scale(0); }
        }

        @keyframes gradientBG { 0% {background-position: 0% 50%;} 50% {background-position: 100% 50%;} 100% {background-position: 0% 50%;} }
    </style>
</head>
<body>
    <!-- Audio Elements -->
    <audio id="wind-sound" loop>
        <source src="https://actions.google.com/sounds/v1/weather/wind_blowing.ogg" type="audio/ogg">
    </audio>
    <audio id="chime-sound">
        <source src="https://actions.google.com/sounds/v1/cartoon/magic_chime.ogg" type="audio/ogg">
    </audio>
    <!-- Background Music (Direct Audio for reliability) -->
    <audio id="bgm-music" loop>
        <source src="https://upload.wikimedia.org/wikipedia/commons/e/e1/Jingle_Bells_-_Kevin_MacLeod.ogg" type="audio/ogg">
    </audio>

    <div id="youtube-player"></div>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <button id="music-btn" onclick="toggleMusic()">üéµ Play Music</button>
        
        <div class="header-container">
            <span class="header-decor">üéÅ</span>
            <span class="header-decor">üîî</span>
            <h1 class="header-text">Merry Christmas</h1>
            <span class="header-decor">üîî</span>
            <span class="header-decor">üéÑ</span>
            <div class="header-sub" style="font-family: 'Itim', cursive; font-size: 2rem; font-weight: 700; color: #fef3c7; text-shadow: 0 2px 4px rgba(0,0,0,0.8);">‡∏™‡∏∏‡∏Ç‡∏™‡∏±‡∏ô‡∏ï‡πå‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏¥‡∏™‡∏ï‡πå‡∏°‡∏≤‡∏™</div>
        </div>
        
        <div id="click-hint" style="font-family: 'Itim', cursive;">‡πÅ‡∏ï‡∏∞/‡∏Ñ‡∏•‡∏¥‡∏Å ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ö‡∏Ç‡∏≠‡∏á‡∏Ç‡∏ß‡∏±‡∏ç!</div>
        <div class="thought-bubble" id="thought-bubble" onclick="santaClicked()" style="font-family: 'Itim', cursive;">‡πÇ‡∏Æ‡πà ‡πÇ‡∏Æ‡πà ‡πÇ‡∏Æ‡πà! Merry Christmas! üéÅ</div>

        <div id="wish-overlay">
            <div id="wish-card">
                <div style="font-size: 3rem; margin-bottom: 10px;">‚ùÑÔ∏èüéÖ‚ú®</div>
                <h2>‡∏Ñ‡∏≥‡∏≠‡∏ß‡∏¢‡∏û‡∏£‡πÅ‡∏î‡πà‡πÄ‡∏ò‡∏≠...</h2>
                <p id="wish-text">...</p>
                <button class="btn-close" onclick="closeWish()">‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏ô‡∏∞‡∏•‡∏∏‡∏á‡∏ã‡∏≤‡∏ô‡∏ï‡πâ‡∏≤ ‚ù§Ô∏è</button>
            </div>
        </div>
    </div>

    <script src="https://www.youtube.com/iframe_api"></script>

    <script>
        let player;
        let isMusicPlaying = false;
        const musicBtn = document.getElementById('music-btn');
        
        const clickHint = document.getElementById('click-hint');
        const wishOverlay = document.getElementById('wish-overlay');
        const wishCard = document.getElementById('wish-card');
        const wishText = document.getElementById('wish-text');
        const bubbleEl = document.getElementById('thought-bubble');

        function onYouTubeIframeAPIReady() {
            player = new YT.Player('youtube-player', {
                height: '0', width: '0', videoId: 'oVo9okHg7uM', // Updated Video ID
                playerVars: { 
                    'playsinline': 1, 
                    'controls': 0,
                    'autoplay': 1,
                    'loop': 1,
                    'playlist': 'oVo9okHg7uM' // Required for loop to work
                },
                events: { 'onReady': onPlayerReady }
            });
        }
        function onPlayerReady(event) {
            event.target.setVolume(30); // Set volume to 30%
            // event.target.playVideo(); // Auto-play might be blocked, handled by interaction
            // isMusicPlaying = true;
            // musicBtn.innerHTML = '‚è∏ Pause Music';
        }

        // Global interaction listener to ensure music plays (browser policy)
        document.body.addEventListener('click', function() {
            if(player && player.getPlayerState() !== 1 && isMusicPlaying) {
                player.playVideo();
            }
        }, { once: true });
        document.body.addEventListener('touchstart', function() {
            if(player && player.getPlayerState() !== 1 && isMusicPlaying) {
                player.playVideo();
            }
        }, { once: true });

        function toggleMusic() {
            if (!player || !player.playVideo) return;
            
            if (isMusicPlaying) {
                player.pauseVideo();
                musicBtn.innerHTML = 'üéµ Play Music';
                isMusicPlaying = false;
            } else {
                player.setVolume(30);
                player.playVideo();
                musicBtn.innerHTML = '‚è∏ Pause Music';
                isMusicPlaying = true;
            }
        }

        // Auto-play attempt on first interaction
        document.body.addEventListener('click', function() {
            if(player && player.getPlayerState() !== 1 && !isMusicPlaying) {
                // Optional: Auto-start on first click if desired
                // toggleMusic(); 
            }
        }, { once: true });

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        // Warm purple fog for magical feel
        scene.fog = new THREE.FogExp2(0x1e1b4b, 0.008); // Reduced fog density for clarity
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); // Max sharpness
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2; // Brighter
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableZoom = false;
        controls.enableRotate = false;
        controls.enablePan = false;

        // --- Lights ---
        const hemiLight = new THREE.HemisphereLight(0xddeeff, 0x2e1065, 0.6); 
        scene.add(hemiLight);

        const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
        scene.add(ambientLight);

        // Warm Village Glow (Ambient)
        const villageLight = new THREE.PointLight(0xffa500, 0.3, 50);
        villageLight.position.set(0, 10, 0);
        scene.add(villageLight);

        const moonLight = new THREE.DirectionalLight(0xdbeafe, 1.0); 
        moonLight.position.set(30, 50, -40);
        moonLight.castShadow = true;
        moonLight.shadow.mapSize.width = 2048;
        moonLight.shadow.mapSize.height = 2048;
        moonLight.shadow.camera.far = 150;
        moonLight.shadow.camera.left = -60;
        moonLight.shadow.camera.right = 60;
        moonLight.shadow.camera.top = 60;
        moonLight.shadow.camera.bottom = -60;
        moonLight.shadow.bias = -0.0005;
        scene.add(moonLight);

        // List of lights to pulse for breathing effect
        const breathingLights = [];

        // --- Sky Objects ---
        function createSky() {
            const moonGeo = new THREE.SphereGeometry(4, 32, 32);
            const moonMat = new THREE.MeshBasicMaterial({ color: 0xffffdd });
            const moon = new THREE.Mesh(moonGeo, moonMat);
            moon.position.set(30, 50, -40);
            scene.add(moon);
            
            const moonGlow = new THREE.PointLight(0xffffdd, 0.6, 100);
            moonGlow.position.copy(moon.position);
            scene.add(moonGlow);

            // Background Stars (Small)
            const starGeo = new THREE.BufferGeometry();
            const starCount = 2000;
            const starPos = [];
            const starSizes = [];
            for(let i=0; i<starCount; i++) {
                const x = (Math.random() - 0.5) * 400;
                const y = Math.random() * 200; 
                const z = (Math.random() - 0.5) * 200 - 50; 
                if(y < 5) continue; 
                starPos.push(x,y,z);
                starSizes.push(Math.random() * 0.5 + 0.1);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            starGeo.setAttribute('size', new THREE.Float32BufferAttribute(starSizes, 1));
            const starMat = new THREE.PointsMaterial({color: 0xffffff, size: 0.2, transparent: true, opacity: 0.9});
            const stars = new THREE.Points(starGeo, starMat);
            scene.add(stars);

            // Bright Twinkling Stars (Larger)
            const brightStarGeo = new THREE.BufferGeometry();
            const brightCount = 200;
            const brightPos = [];
            for(let i=0; i<brightCount; i++) {
                brightPos.push((Math.random()-0.5)*300, Math.random()*150 + 10, (Math.random()-0.5)*300 - 50);
            }
            brightStarGeo.setAttribute('position', new THREE.Float32BufferAttribute(brightPos, 3));
            const brightMat = new THREE.PointsMaterial({color: 0xa5f3fc, size: 0.6, transparent: true, opacity: 0.8});
            const brightStars = new THREE.Points(brightStarGeo, brightMat);
            scene.add(brightStars);
            
            // Store for animation
            window.twinklingStars = brightStars;
        }
        createSky();

        // --- 1. The Ground & Roads ---
        const groundGeometry = new THREE.PlaneGeometry(150, 150, 128, 128); // Higher resolution
        const posAttr = groundGeometry.attributes.position;
        for(let i=0; i < posAttr.count; i++) {
            const x = posAttr.getX(i);
            const y = posAttr.getY(i);
            
            // Rolling hills
            let height = Math.sin(x * 0.05) * 1.5 + Math.cos(y * 0.05) * 1.5;
            // Detail noise
            height += Math.random() * 0.2;
            
            const distFromCenter = Math.sqrt(x*x + y*y);
            if (distFromCenter < 25) height *= (distFromCenter/25); // Smooth flatten
            
            posAttr.setZ(i, height);
        }
        groundGeometry.computeVertexNormals();
        const ground = new THREE.Mesh(
            groundGeometry, 
            new THREE.MeshStandardMaterial({ 
                color: 0xe2e8f0, 
                roughness: 0.9, 
                metalness: 0.1,
                flatShading: false
            })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -2;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- Roads ---
        const roadGroup = new THREE.Group();
        const roadMat = new THREE.MeshStandardMaterial({ 
            color: 0x94a3b8, roughness: 1.0, metalness: 0.0, 
            side: THREE.DoubleSide 
        });

        // 1. Main Ring Road
        const ringGeo = new THREE.RingGeometry(18, 24, 64);
        const ringRoad = new THREE.Mesh(ringGeo, roadMat);
        ringRoad.rotation.x = -Math.PI / 2;
        ringRoad.position.y = -1.95;
        ringRoad.receiveShadow = true;
        roadGroup.add(ringRoad);
        
        // 2. Paths to Houses (Cross shape)
        const pathGeo = new THREE.PlaneGeometry(4, 40);
        const path1 = new THREE.Mesh(pathGeo, roadMat);
        path1.rotation.x = -Math.PI / 2;
        path1.position.y = -1.96;
        roadGroup.add(path1);

        const path2 = new THREE.Mesh(pathGeo, roadMat);
        path2.rotation.x = -Math.PI / 2;
        path2.rotation.z = Math.PI / 2;
        path2.position.y = -1.96;
        roadGroup.add(path2);

        // 3. Path to Pond
        const pondPath = new THREE.Mesh(new THREE.PlaneGeometry(3, 12), roadMat);
        pondPath.rotation.x = -Math.PI / 2;
        pondPath.rotation.z = -0.6;
        pondPath.position.set(-12, -1.95, 6);
        roadGroup.add(pondPath);

        scene.add(roadGroup);

        // --- Distant City (Skyline) ---
        function createDistantCity() {
            const cityGroup = new THREE.Group();
            const buildingGeo = new THREE.BoxGeometry(1, 1, 1);
            const buildingMat = new THREE.MeshBasicMaterial({ color: 0x0f172a }); // Dark silhouette
            const windowMat = new THREE.MeshBasicMaterial({ color: 0xfef08a }); // Warm light

            for(let i=0; i<50; i++) {
                const h = 5 + Math.random() * 15;
                const w = 2 + Math.random() * 3;
                const d = 2 + Math.random() * 3;
                const building = new THREE.Mesh(buildingGeo, buildingMat);
                building.scale.set(w, h, d);
                
                // Place on horizon arc
                const angle = (Math.random() - 0.5) * Math.PI; // -90 to 90 degrees
                const dist = 80 + Math.random() * 20;
                building.position.set(Math.sin(angle)*dist, h/2 - 5, Math.cos(angle)*dist - 20);
                
                // Add windows
                for(let j=0; j<5; j++) {
                    if(Math.random() > 0.3) {
                        const win = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 0.6), windowMat);
                        win.position.set(0, (Math.random()-0.5)*h*0.8, 0.51);
                        building.add(win);
                    }
                }
                cityGroup.add(building);
            }
            scene.add(cityGroup);
        }
        createDistantCity();

        // Frozen Pond
        const pondGeo = new THREE.CircleGeometry(6, 32);
        const pondMat = new THREE.MeshStandardMaterial({ 
            color: 0xa5f3fc, roughness: 0.05, metalness: 0.8, transparent: true, opacity: 0.85
        });
        const pond = new THREE.Mesh(pondGeo, pondMat);
        pond.rotation.x = -Math.PI/2;
        pond.position.set(-15, -1.9, 8);
        pond.receiveShadow = true;
        scene.add(pond);

        // Bonfire (Warmth Center)
        function createBonfire(x, z) {
            const group = new THREE.Group();
            // Logs
            const logMat = new THREE.MeshStandardMaterial({ color: 0x451a03 });
            for(let i=0; i<5; i++) {
                const log = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.5), logMat);
                log.rotation.set(Math.random()*0.5, Math.random()*Math.PI, Math.PI/2 + (Math.random()-0.5)*0.5);
                log.position.y = 0.2;
                group.add(log);
            }
            // Fire Light
            const fireLight = new THREE.PointLight(0xff4500, 2, 10);
            fireLight.position.y = 1;
            fireLight.castShadow = true;
            group.add(fireLight);
            
            // Fire Particles (Simple)
            const fireGeo = new THREE.ConeGeometry(0.5, 1, 4);
            const fireMat = new THREE.MeshBasicMaterial({ color: 0xff4500, transparent: true, opacity: 0.8 });
            const fireMesh = new THREE.Mesh(fireGeo, fireMat);
            fireMesh.position.y = 0.5;
            group.add(fireMesh);
            
            // Animate fire
            setInterval(() => {
                fireLight.intensity = 1.5 + Math.random();
                fireMesh.scale.setScalar(0.8 + Math.random() * 0.4);
                fireMesh.rotation.y += 0.1;
            }, 100);

            group.position.set(x, -1.8, z);
            scene.add(group);
        }
        createBonfire(-10, 5); // Near the pond area
        createBonfire(10, 5);  // Another one on the other side

        // Rocks
        function createRock(x, z) {
            const geo = new THREE.DodecahedronGeometry(0.3 + Math.random()*0.3, 0);
            const mat = new THREE.MeshStandardMaterial({ color: 0x64748b, flatShading:true });
            const rock = new THREE.Mesh(geo, mat);
            rock.position.set(x, -1.8, z);
            rock.rotation.set(Math.random(), Math.random(), Math.random());
            rock.castShadow = true;
            scene.add(rock);
        }
        for(let i=0; i<20; i++) createRock((Math.random()-0.5)*50, (Math.random()-0.5)*50);

        // Roads
        const pathMat = new THREE.MeshStandardMaterial({ color: 0x57534e, roughness: 1, side: THREE.DoubleSide });
        function createPath(radius, width) {
            const pathGeo = new THREE.RingGeometry(radius, radius + width, 64);
            const path = new THREE.Mesh(pathGeo, pathMat);
            path.rotation.x = -Math.PI / 2;
            path.position.y = -1.8; 
            path.receiveShadow = true;
            scene.add(path);
        }
        createPath(3, 2); 
        function createStraightPath(x, z, w, l, r) {
            const geo = new THREE.PlaneGeometry(w, l);
            const path = new THREE.Mesh(geo, pathMat);
            path.rotation.x = -Math.PI / 2; path.rotation.z = r; path.position.set(x, -1.8, z);
            path.receiveShadow = true; scene.add(path);
        }
        createStraightPath(-12, -4, 2, 10, Math.PI/6);
        createStraightPath(12, -3, 2, 10, -Math.PI/6);
        createStraightPath(0, 7, 2, 8, 0);

        // --- 2. Village Details ---
        const smokeParticles = [];
        const walkers = [];
        const obstacles = []; // Store obstacles for collision detection

        function registerObstacle(x, z, radius) {
            obstacles.push({ x, z, radius });
        }

        function createFence(x, z, width, depth, rotation) {
            const fenceGroup = new THREE.Group();
            const postGeo = new THREE.BoxGeometry(0.1, 0.8, 0.1);
            const railGeo = new THREE.BoxGeometry(width, 0.1, 0.05);
            const mat = new THREE.MeshStandardMaterial({color: 0x5c4033});
            const rail = new THREE.Mesh(railGeo, mat); rail.position.y = 0.5; fenceGroup.add(rail);
            const postCount = Math.floor(width / 1);
            for(let i=0; i<=postCount; i++) {
                const post = new THREE.Mesh(postGeo, mat);
                post.position.set((i/postCount)*width - width/2, 0.4, 0);
                fenceGroup.add(post);
            }
            fenceGroup.position.set(x, -2, z); fenceGroup.rotation.y = rotation; scene.add(fenceGroup);
        }

        function createHouse(x, z, rotation, color = 0xfefce8, scale=1) {
            const houseGroup = new THREE.Group();
            const width = 4 * scale;
            
            // Main Walls
            const walls = new THREE.Mesh(new THREE.BoxGeometry(width, 3*scale, 3*scale), new THREE.MeshStandardMaterial({ color: color, roughness: 0.8 }));
            walls.position.y = (1.5*scale); walls.castShadow = true; walls.receiveShadow = true; houseGroup.add(walls);
            
            // Roof Structure
            const roofHeight = 2 * scale;
            const roofGeo = new THREE.ConeGeometry(3.5*scale, roofHeight, 4);
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x7f1d1d, roughness: 0.6 });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = (3*scale + roofHeight/2); roof.rotation.y = Math.PI / 4; roof.castShadow = true; houseGroup.add(roof);
            
            // Physics-based Snow Blanket (Thick & Overhanging)
            const snowGeo = new THREE.ConeGeometry(3.7*scale, roofHeight, 4);
            const snowMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1.0, metalness: 0.0 });
            const snowRoof = new THREE.Mesh(snowGeo, snowMat);
            snowRoof.position.y = (3*scale + roofHeight/2 + 0.1*scale); // Slightly higher
            snowRoof.rotation.y = Math.PI / 4; 
            snowRoof.scale.set(1.05, 1, 1.05); // Wider than roof
            houseGroup.add(snowRoof);

            // Snow Drifts/Overhangs at corners (The "Physics" look)
            const driftGeo = new THREE.SphereGeometry(0.4*scale, 8, 8);
            for(let i=0; i<4; i++) {
                const drift = new THREE.Mesh(driftGeo, snowMat);
                const angle = (Math.PI/2) * i;
                const r = 2.5 * scale; // Distance from center
                drift.position.set(Math.sin(angle)*r, 3*scale, Math.cos(angle)*r);
                drift.scale.set(1.5, 0.8, 1.5); // Flattened
                houseGroup.add(drift);
            }

            // Chimney
            const chimney = new THREE.Mesh(new THREE.BoxGeometry(0.6*scale, 1.5*scale, 0.6*scale), new THREE.MeshStandardMaterial({ color: 0x475569 }));
            chimney.position.set(1.2*scale, 3.5*scale, 0.5*scale); houseGroup.add(chimney);
            
            // Chimney Snow Cap (Mounded)
            const chimSnow = new THREE.Mesh(new THREE.SphereGeometry(0.5*scale, 8, 8), snowMat);
            chimSnow.position.set(1.2*scale, 4.3*scale, 0.5*scale); 
            chimSnow.scale.set(1, 0.6, 1);
            houseGroup.add(chimSnow);

            // Door Frame & Door
            const frameGeo = new THREE.PlaneGeometry(1.2*scale, 2.2*scale);
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x271c19 });
            const frame = new THREE.Mesh(frameGeo, frameMat); frame.position.set(0, 1*scale, 1.505*scale); houseGroup.add(frame);
            const door = new THREE.Mesh(new THREE.PlaneGeometry(1*scale, 2*scale), new THREE.MeshStandardMaterial({ color: 0x451a03 }));
            door.position.set(0, 1*scale, 1.51*scale); houseGroup.add(door);
            
            // Wreath on Door
            const wreath = new THREE.Group();
            const torus = new THREE.Mesh(new THREE.TorusGeometry(0.3*scale, 0.1*scale, 8, 16), new THREE.MeshStandardMaterial({ color: 0x15803d }));
            wreath.add(torus);
            const bow = new THREE.Mesh(new THREE.SphereGeometry(0.1*scale), new THREE.MeshStandardMaterial({ color: 0xdc2626 }));
            bow.position.y = -0.25*scale; wreath.add(bow);
            wreath.position.set(0, 1.6*scale, 1.55*scale);
            houseGroup.add(wreath);

            // Warm Glowing Windows (Brighter)
            const winMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffa500, emissiveIntensity: 1.5 });
            const win1 = new THREE.Mesh(new THREE.PlaneGeometry(0.8*scale, 0.8*scale), winMat); win1.position.set(-1.2*scale, 1.5*scale, 1.51*scale); houseGroup.add(win1);
            const win2 = new THREE.Mesh(new THREE.PlaneGeometry(0.8*scale, 0.8*scale), winMat); win2.position.set(1.2*scale, 1.5*scale, 1.51*scale); houseGroup.add(win2);
            
            // Add a local warm light for each house
            const houseLight = new THREE.PointLight(0xffa500, 1.0, 8);
            houseLight.position.set(0, 2*scale, 3*scale);
            houseGroup.add(houseLight);
            breathingLights.push(houseLight);

            houseGroup.position.set(x, -2, z); houseGroup.rotation.y = rotation; scene.add(houseGroup);
            createFence(x, z + 2.5*scale, 5*scale, 0.1, rotation);
            setInterval(() => {
                const offset = new THREE.Vector3(1.2*scale, 3.5*scale + 1, 0.5*scale); offset.applyEuler(new THREE.Euler(0, rotation, 0)); offset.add(new THREE.Vector3(x, -2, z));
                spawnSmoke(offset);
            }, 300 + Math.random() * 200);

            // Register Obstacle (Approximate radius)
            registerObstacle(x, z, 3.5 * scale);
        }

        function createSnowman(x, z) {
            const group = new THREE.Group();
            const snowMat = new THREE.MeshStandardMaterial({color: 0xffffff, roughness: 0.8});
            const bot = new THREE.Mesh(new THREE.SphereGeometry(0.6), snowMat); bot.position.y = 0.5; group.add(bot);
            const mid = new THREE.Mesh(new THREE.SphereGeometry(0.4), snowMat); mid.position.y = 1.3; group.add(mid);
            const top = new THREE.Mesh(new THREE.SphereGeometry(0.25), snowMat); top.position.y = 1.85; group.add(top);
            const nose = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.2, 8), new THREE.MeshStandardMaterial({color: 0xf97316}));
            nose.rotation.x = Math.PI/2; nose.position.set(0, 1.85, 0.25); group.add(nose);
            group.position.set(x, -2, z); scene.add(group);
            registerObstacle(x, z, 1.0);
        }

        function createDetailedStreetLamp(x, z) {
            const group = new THREE.Group();
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 0.5, 6), new THREE.MeshStandardMaterial({ color: 0x111827 }));
            base.position.y = 0.25; group.add(base);
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.12, 4.5), new THREE.MeshStandardMaterial({ color: 0x1f2937 }));
            pole.position.y = 2.5; group.add(pole);
            const bar = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 0.1), new THREE.MeshStandardMaterial({ color: 0x111827 }));
            bar.position.y = 4.2; group.add(bar);
            function createLantern(ox) {
                const lGroup = new THREE.Group();
                const frame = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.6, 0.4), new THREE.MeshStandardMaterial({ color: 0x111827 }));
                lGroup.add(frame);
                const glass = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.5, 0.3), new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffa500, emissiveIntensity: 1.2 }));
                lGroup.add(glass); lGroup.position.set(ox, 4.0, 0); return lGroup;
            }
            group.add(createLantern(0.5)); group.add(createLantern(-0.5));
            const light = new THREE.PointLight(0xffa500, 1.5, 15); light.position.y = 4; group.add(light);
            breathingLights.push(light); // Add to breathing lights
            group.position.set(x, -2, z); scene.add(group);
            registerObstacle(x, z, 0.5);
        }

        function createDetailedPerson(x, z) {
            const group = new THREE.Group();
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xfca5a5 });
            const clothesColor = Math.random() > 0.5 ? 0xef4444 : 0x2563eb;
            const clothesMat = new THREE.MeshStandardMaterial({ color: clothesColor });
            const pantsMat = new THREE.MeshStandardMaterial({ color: 0x1f2937 });
            const bootMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const mittenMat = new THREE.MeshStandardMaterial({ color: 0x166534 });

            // 1. Body (Coat) - Rounded
            const bodyGeo = new THREE.CylinderGeometry(0.2, 0.35, 0.7, 8);
            const body = new THREE.Mesh(bodyGeo, clothesMat); 
            body.position.y = 0.85; body.castShadow = true; body.receiveShadow = true; group.add(body);
            
            // 2. Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.2), skinMat); 
            head.position.y = 1.35; head.castShadow = true; head.receiveShadow = true; group.add(head);
            
            // 3. Hat (Beanie style)
            const hatGroup = new THREE.Group();
            const hatBase = new THREE.Mesh(new THREE.SphereGeometry(0.21, 16, 16, 0, Math.PI*2, 0, Math.PI/2), clothesMat);
            hatBase.position.y = 1.4; hatGroup.add(hatBase);
            const hatBrim = new THREE.Mesh(new THREE.TorusGeometry(0.2, 0.05, 8, 16), new THREE.MeshStandardMaterial({color: 0xffffff}));
            hatBrim.position.y = 1.4; hatBrim.rotation.x = Math.PI/2; hatGroup.add(hatBrim);
            const pom = new THREE.Mesh(new THREE.SphereGeometry(0.07), new THREE.MeshStandardMaterial({color: 0xffffff}));
            pom.position.y = 1.65; hatGroup.add(pom);
            group.add(hatGroup);
            
            // 4. Scarf
            const scarf = new THREE.Mesh(new THREE.TorusGeometry(0.16, 0.07, 8, 16), new THREE.MeshStandardMaterial({color: 0xffb700}));
            scarf.position.y = 1.22; scarf.rotation.x = Math.PI/2; scarf.castShadow = true; group.add(scarf);
            
            // 5. Legs with Boots
            function createLeg(ox) {
                const lGroup = new THREE.Group();
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.06, 0.5), pantsMat);
                leg.position.y = -0.25; lGroup.add(leg);
                const boot = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, 0.2), bootMat);
                boot.position.set(0, -0.5, 0.05); lGroup.add(boot);
                lGroup.position.set(ox, 0.5, 0);
                return lGroup;
            }
            const legL = createLeg(-0.12); group.add(legL);
            const legR = createLeg(0.12); group.add(legR);
            
            // 6. Arms with Mittens
            function createArm(ox, rz) {
                const aGroup = new THREE.Group();
                const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.05, 0.45), clothesMat);
                arm.position.y = -0.2; aGroup.add(arm);
                const mitten = new THREE.Mesh(new THREE.SphereGeometry(0.08), mittenMat);
                mitten.position.y = -0.45; aGroup.add(mitten);
                aGroup.position.set(ox, 1.1, 0); aGroup.rotation.z = rz;
                return aGroup;
            }
            const armL = createArm(-0.28, 0.3); group.add(armL);
            const armR = createArm(0.28, -0.3); group.add(armR);
            
            group.position.set(x, -2, z); 
            group.scale.set(1.2, 1.2, 1.2); 
            scene.add(group);
            walkers.push({ type: 'person', mesh: group, legL, legR, armL, armR, speed: 0.02 + Math.random() * 0.01, turnSpeed: 0.03, angle: Math.random()*Math.PI*2, targetAngle: Math.random()*Math.PI*2, walkTime: 0 });
        }

        function createDog(x, z) {
            const group = new THREE.Group();
            const furMat = new THREE.MeshStandardMaterial({ color: 0xa16207 });
            const noseMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            // 1. Body (Rounded Cylinder)
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.18, 0.5, 8), furMat); 
            body.rotation.x = Math.PI / 2;
            body.position.y = 0.3; body.castShadow = true; body.receiveShadow = true; group.add(body);
            
            // 2. Head
            const headGroup = new THREE.Group();
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.22, 0.25), furMat); 
            head.position.set(0, 0, 0); head.castShadow = true; head.receiveShadow = true; headGroup.add(head);
            
            // Snout
            const snout = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.15), furMat);
            snout.position.set(0, -0.05, 0.15); headGroup.add(snout);
            const nose = new THREE.Mesh(new THREE.SphereGeometry(0.04), noseMat);
            nose.position.set(0, 0, 0.22); headGroup.add(nose);

            // Ears (Floppy)
            const earL = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.15, 0.08), furMat);
            earL.position.set(-0.12, 0.05, 0); earL.rotation.z = 0.3; headGroup.add(earL);
            const earR = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.15, 0.08), furMat);
            earR.position.set(0.12, 0.05, 0); earR.rotation.z = -0.3; headGroup.add(earR);
            
            headGroup.position.set(0, 0.55, 0.25);
            group.add(headGroup);

            // 3. Legs (Cylinders)
            function createLeg(ox, oz) {
                const lGroup = new THREE.Group();
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.04, 0.3), furMat);
                leg.position.y = -0.15; lGroup.add(leg);
                lGroup.position.set(ox, 0.3, oz);
                return lGroup;
            }
            const l1 = createLeg(-0.1, 0.15); group.add(l1);
            const l2 = createLeg(0.1, 0.15); group.add(l2);
            const l3 = createLeg(-0.1, -0.15); group.add(l3);
            const l4 = createLeg(0.1, -0.15); group.add(l4);
            
            // 4. Tail
            const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.02, 0.25), furMat); 
            tail.position.set(0, 0.45, -0.25); tail.rotation.x = -0.8; tail.castShadow = true; group.add(tail);
            
            group.position.set(x, -2, z); 
            group.scale.set(1.2, 1.2, 1.2); 
            scene.add(group);
            
            // Animation references need to match the structure
            // Note: In the animation loop, we access l1.rotation.x directly. 
            // Since l1 is now a Group, we need to rotate the group or the mesh inside.
            // The animation loop does: w.legs.forEach(l => l.rotation.x = ...)
            // Rotating the group (l1) works fine.
            walkers.push({ type: 'dog', mesh: group, legs: [l1, l2, l3, l4], tail, speed: 0.04, angle: Math.random()*Math.PI*2, targetAngle: Math.random()*Math.PI*2, walkTime: 0 });
        }

        function spawnSmoke(pos) {
            const p = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 }));
            p.position.copy(pos); p.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
            scene.add(p); smokeParticles.push({ mesh: p, life: 100 });
        }

        createHouse(-18, -2, Math.PI / 6, 0xfefce8, 1.2);
        createHouse(18, -2, -Math.PI / 4, 0xdbeafe, 1.1);
        createHouse(-6, 12, Math.PI, 0xffedd5, 1.0);
        createHouse(8, 10, -Math.PI / 2, 0xe0e7ff, 0.9);
        
        createSnowman(-3, 8);
        createSnowman(3, -5);

        createDetailedStreetLamp(-6, 6);
        createDetailedStreetLamp(6, 6);
        createDetailedStreetLamp(-10, -2);
        createDetailedStreetLamp(10, -2);

        for(let i=0; i<8; i++) createDetailedPerson((Math.random()-0.5)*20, 6 + (Math.random()-0.5)*10);
        createDog(4, 4);
        createDog(-4, 7);

        // --- 3. Green Forest Trees (Dense) ---
        function createSimpleTree(x, z, scale) {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0x15803d, flatShading: true });
            const c1 = new THREE.Mesh(new THREE.ConeGeometry(1.5, 3, 5), mat); c1.position.y = 1.5; c1.castShadow = true; group.add(c1);
            const c2 = new THREE.Mesh(new THREE.ConeGeometry(2, 3, 5), mat); c2.position.y = 0; c2.castShadow = true; group.add(c2);
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1), new THREE.MeshStandardMaterial({color: 0x451a03}));
            trunk.position.y = -0.5; group.add(trunk);
            group.position.set(x, scale - 2, z); group.scale.set(scale, scale, scale); scene.add(group);
        }
        for(let i=0; i<150; i++) { // Increased count for density
            const angle = Math.random() * Math.PI * 2;
            const dist = 30 + Math.random() * 50; 
            createSimpleTree(Math.cos(angle)*dist, Math.sin(angle)*dist, 0.8 + Math.random() * 0.8);
        }

        // --- 4. Gifts (Raised) ---
        const giftGroup = new THREE.Group();
        function createGift(x, z, colorHex, scale = 1, rotationY = 0, tilt = 0) {
            const size = 0.6 * scale;
            const geo = new THREE.BoxGeometry(size, size, size);
            const mat = new THREE.MeshStandardMaterial({ color: colorHex, emissive: colorHex, emissiveIntensity: 0.3, roughness: 0.2, metalness: 0.3 });
            const box = new THREE.Mesh(geo, mat); box.castShadow = true;
            const ribbonMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.1 });
            const rib1 = new THREE.Mesh(new THREE.BoxGeometry(size * 1.05, size, size * 0.2), ribbonMat);
            const rib2 = new THREE.Mesh(new THREE.BoxGeometry(size * 0.2, size, size * 1.05), ribbonMat);
            const bow = new THREE.Mesh(new THREE.TorusGeometry(size*0.15, 0.05, 8, 16), ribbonMat);
            bow.position.y = size/2 + 0.1; bow.rotation.x = Math.PI/2;
            const gift = new THREE.Group(); gift.add(box); gift.add(rib1); gift.add(rib2); gift.add(bow);
            gift.position.set(x, -1.5 + size/2, z); 
            gift.rotation.y = rotationY; gift.rotation.z = tilt;
            giftGroup.add(gift);
        }
        
        // Generate Lots of Gifts!
        const giftColors = [0xef4444, 0x3b82f6, 0xf59e0b, 0x8b5cf6, 0xec4899, 0x10b981, 0xf43f5e, 0x6366f1, 0xfcd34d, 0x14b8a6];
        
        // 1. Around the Tree (Dense)
        for(let i=0; i<30; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 1.2 + Math.random() * 2.5; // Spread out a bit more
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const color = giftColors[Math.floor(Math.random() * giftColors.length)];
            const scale = 0.5 + Math.random() * 0.8;
            const rot = Math.random() * Math.PI;
            const tilt = (Math.random() - 0.5) * 0.2;
            createGift(x, z, color, scale, rot, tilt);
        }

        // 2. Scattered around the village (Surprises)
        for(let i=0; i<15; i++) {
            const x = (Math.random() - 0.5) * 30;
            const z = (Math.random() - 0.5) * 30;
            // Avoid center
            if (Math.sqrt(x*x + z*z) < 5) continue;
            
            const color = giftColors[Math.floor(Math.random() * giftColors.length)];
            createGift(x, z, color, 0.6 + Math.random()*0.4, Math.random()*Math.PI, 0);
        }

        scene.add(giftGroup);
        const giftLight = new THREE.PointLight(0xffd700, 0.5, 5); giftLight.position.set(0, -1, 0); scene.add(giftLight);
        breathingLights.push(giftLight);

        // Candy Canes
        function createCandyCane(x, z, rot) {
            const caneGroup = new THREE.Group();
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 1.5, 0),
                new THREE.Vector3(0.3, 1.8, 0),
                new THREE.Vector3(0.6, 1.5, 0)
            ]);
            const tubeGeo = new THREE.TubeGeometry(curve, 20, 0.08, 8, false);
            const tubeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const cane = new THREE.Mesh(tubeGeo, tubeMat);
            
            // Red stripes (simplified as rings for now or texture, let's use rings)
            for(let i=0; i<10; i++) {
                const ring = new THREE.Mesh(new THREE.TorusGeometry(0.09, 0.02, 8, 16), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                const pt = curve.getPoint(i/10);
                ring.position.copy(pt);
                if(i < 7) ring.rotation.x = Math.PI/2;
                else ring.rotation.z = Math.PI/2; // Approximate rotation for hook
                caneGroup.add(ring);
            }
            
            caneGroup.add(cane);
            caneGroup.position.set(x, -2, z);
            caneGroup.rotation.y = rot;
            caneGroup.castShadow = true;
            scene.add(caneGroup);
        }
        createCandyCane(-2, 2, Math.PI/4);
        createCandyCane(2, 2, -Math.PI/4);
        createCandyCane(-2, -2, Math.PI*0.75);
        createCandyCane(2, -2, -Math.PI*0.75);

        // --- 5. Main Tree ---
        let treeGroup = new THREE.Group();
        function createMainTree() {
            treeGroup = new THREE.Group();
            const levels = 9; const treeColors = [0x15803d, 0x166534, 0x14532d];
            
            // Tree Spotlight
            const treeLight = new THREE.SpotLight(0xffd700, 1.5);
            treeLight.position.set(5, 15, 5);
            treeLight.target = treeGroup;
            treeLight.angle = 0.5;
            treeLight.penumbra = 0.5;
            treeLight.castShadow = true;
            scene.add(treeLight);

            for (let i = 0; i < levels; i++) {
                const ratio = i / (levels - 1); 
                const radius = 0.4 + ratio * 2.8; // Slightly wider for height balance
                const height = 1.0; 
                const yPos = (levels - 1 - i) * 0.7 + 0.5;
                
                const geometry = new THREE.ConeGeometry(radius, height, 16); // More segments for roundness
                const material = new THREE.MeshStandardMaterial({ color: treeColors[i % 3], flatShading: true, roughness: 0.7 });
                const layer = new THREE.Mesh(geometry, material); 
                layer.position.y = yPos; 
                layer.castShadow = true; 
                layer.receiveShadow = true; 
                layer.userData = { type: 'leaf' }; 
                treeGroup.add(layer);
                
                const snowGeo = new THREE.ConeGeometry(radius * 0.95, height * 0.3, 16);
                const snowMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const snow = new THREE.Mesh(snowGeo, snowMat); 
                snow.position.y = yPos + 0.1; 
                snow.castShadow = true;
                snow.receiveShadow = true;
                treeGroup.add(snow);
            }
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 1.0, 2.5, 10), new THREE.MeshStandardMaterial({ color: 0x451a03 })); 
            trunk.position.y = -0.5; 
            trunk.castShadow = true; 
            trunk.receiveShadow = true;
            treeGroup.add(trunk);
            
            const star = new THREE.Mesh(new THREE.IcosahedronGeometry(0.6, 0), new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffa500, emissiveIntensity: 0.8 })); 
            star.position.y = (levels * 0.7) + 0.6; 
            treeGroup.add(star);
            
            const ornamentColors = [0xef4444, 0x3b82f6, 0xfcd34d, 0xffffff, 0xec4899];
            for (let i = 0; i < 70; i++) { // Adjusted ornaments
                const color = ornamentColors[Math.floor(Math.random()*ornamentColors.length)];
                const orb = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.6, metalness: 0.8, roughness: 0.1 }));
                const levelIdx = Math.floor(Math.random() * levels); 
                const ratio = levelIdx / (levels - 1); 
                const radiusAtLevel = 0.4 + ratio * 2.8; 
                const yBase = (levels - 1 - levelIdx) * 0.7 + 0.5;
                const theta = Math.random() * Math.PI * 2; 
                const r = radiusAtLevel * (0.8 + Math.random() * 0.2); 
                orb.position.set(Math.cos(theta) * r, yBase - 0.2, Math.sin(theta) * r); 
                orb.castShadow = true;
                orb.receiveShadow = true;
                treeGroup.add(orb);
            }
            scene.add(treeGroup);
        }
        createMainTree();

        // --- 6. Santa & Arrival Light ---
        let santaGroup = new THREE.Group();
        let reindeerLegs = [];
        let reindeerHeads = []; // Store heads for animation
        let arrivalSpotlight;
        let santaRightArm; 
        let santaBody; // Store body for bounce

        function createSantaSystem() {
            const sleighGroup = new THREE.Group();
            
            // Arrival Spotlight
            arrivalSpotlight = new THREE.SpotLight(0xffd700, 0); 
            arrivalSpotlight.position.set(0, 20, 0); 
            arrivalSpotlight.target = sleighGroup;
            arrivalSpotlight.angle = 0.5;
            arrivalSpotlight.penumbra = 0.5;
            arrivalSpotlight.castShadow = true;
            scene.add(arrivalSpotlight);

            // --- 1. Detailed Sleigh ---
            const sleighBodyMat = new THREE.MeshStandardMaterial({ color: 0xb91c1c, roughness: 0.3, metalness: 0.1 }); 
            const goldMat = new THREE.MeshStandardMaterial({ color: 0xfbbf24, metalness: 0.8, roughness: 0.2 });
            const seatMat = new THREE.MeshStandardMaterial({ color: 0x451a03 });

            // Curved Runners
            function createRunner(zOffset) {
                const curve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(0, 0.2, 1.5),
                    new THREE.Vector3(0, 0, 1.0),
                    new THREE.Vector3(0, 0, -1.0),
                    new THREE.Vector3(0, 0.5, -1.5),
                    new THREE.Vector3(0, 1.0, -1.8) // Curl up at front
                ]);
                const runner = new THREE.Mesh(new THREE.TubeGeometry(curve, 20, 0.05, 8, false), goldMat);
                runner.position.x = zOffset;
                return runner;
            }
            sleighGroup.add(createRunner(0.6));
            sleighGroup.add(createRunner(-0.6));

            // Sleigh Body (Curved Shell)
            const shellShape = new THREE.Shape();
            shellShape.moveTo(-0.6, 0);
            shellShape.lineTo(0.6, 0);
            shellShape.lineTo(0.7, 1.0); // Side flare
            shellShape.lineTo(-0.7, 1.0);
            shellShape.lineTo(-0.6, 0);
            
            const extrudeSettings = { steps: 2, depth: 2.0, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05, bevelSegments: 2 };
            const sleighBodyMesh = new THREE.Mesh(new THREE.ExtrudeGeometry(shellShape, extrudeSettings), sleighBodyMat);
            sleighBodyMesh.position.set(0, 0.4, -1.0); // Center it
            sleighGroup.add(sleighBodyMesh);

            // Seat
            const seat = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.2, 0.8), seatMat);
            seat.position.set(0, 0.8, -0.5);
            sleighGroup.add(seat);

            // Bag of Gifts
            const bag = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.7), new THREE.MeshStandardMaterial({ color: 0x854d0e }));
            bag.position.set(0, 1.0, -1.2);
            bag.rotation.x = Math.PI;
            sleighGroup.add(bag);


            // --- 2. Detailed Santa ---
            santaBody = new THREE.Group(); 
            santaBody.position.set(0, 1.0, -0.5); // Sit on seat

            const suitMat = new THREE.MeshStandardMaterial({ color: 0xdc2626 });
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xfca5a5 });
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const bootMat = new THREE.MeshStandardMaterial({ color: 0x1f2937 });

            // Torso (Fat)
            const torso = new THREE.Mesh(new THREE.SphereGeometry(0.45, 16, 16), suitMat); 
            torso.position.y = 0.4; santaBody.add(torso);
            
            // Belt
            const belt = new THREE.Mesh(new THREE.CylinderGeometry(0.46, 0.46, 0.1, 16), new THREE.MeshStandardMaterial({color: 0x000000}));
            belt.position.y = 0.3; santaBody.add(belt);
            const buckle = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.05), goldMat);
            buckle.position.set(0, 0.3, 0.45); santaBody.add(buckle);

            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.22), skinMat); 
            head.position.y = 0.95; santaBody.add(head);
            
            // Beard
            const beard = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 16, 0, Math.PI*2, 0, Math.PI/2), whiteMat); 
            beard.position.set(0, 0.85, 0.12); beard.rotation.x = -0.2; santaBody.add(beard);

            // Hat
            const hatGroup = new THREE.Group();
            const hatBase = new THREE.Mesh(new THREE.SphereGeometry(0.23, 16, 16, 0, Math.PI*2, 0, Math.PI/2), suitMat);
            hatBase.position.y = 1.05; hatGroup.add(hatBase);
            const hatBrim = new THREE.Mesh(new THREE.TorusGeometry(0.22, 0.06, 8, 16), whiteMat);
            hatBrim.position.y = 1.05; hatBrim.rotation.x = Math.PI/2; hatGroup.add(hatBrim);
            const pom = new THREE.Mesh(new THREE.SphereGeometry(0.08), whiteMat);
            pom.position.set(0, 1.4, -0.1); hatGroup.add(pom);
            santaBody.add(hatGroup);

            // Legs (Sitting)
            const legGeo = new THREE.CylinderGeometry(0.12, 0.1, 0.5);
            const legL = new THREE.Mesh(legGeo, suitMat); legL.position.set(0.2, 0.2, 0.4); legL.rotation.x = -Math.PI/2; santaBody.add(legL);
            const legR = new THREE.Mesh(legGeo, suitMat); legR.position.set(-0.2, 0.2, 0.4); legR.rotation.x = -Math.PI/2; santaBody.add(legR);
            const bootL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.25), bootMat); bootL.position.set(0.2, 0.1, 0.7); santaBody.add(bootL);
            const bootR = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.25), bootMat); bootR.position.set(-0.2, 0.1, 0.7); santaBody.add(bootR);

            // Arms
            const armGeo = new THREE.CylinderGeometry(0.1, 0.08, 0.45);
            
            // Left Arm (Holding Reins)
            const armL = new THREE.Mesh(armGeo, suitMat); armL.position.set(0.45, 0.6, 0.2); armL.rotation.x = -0.5; armL.rotation.z = -0.2; santaBody.add(armL);
            const mitL = new THREE.Mesh(new THREE.SphereGeometry(0.12), new THREE.MeshStandardMaterial({color: 0x166534})); mitL.position.set(0, -0.25, 0); armL.add(mitL);

            // Right Arm (Waving Pivot)
            const armGroupR = new THREE.Group();
            armGroupR.position.set(-0.45, 0.6, 0); 
            const armR = new THREE.Mesh(armGeo, suitMat);
            armR.position.y = -0.2; // Offset so pivot is at shoulder
            armGroupR.add(armR);
            const mitR = new THREE.Mesh(new THREE.SphereGeometry(0.12), new THREE.MeshStandardMaterial({color: 0x166534})); 
            mitR.position.y = -0.45; armR.add(mitR);
            
            santaBody.add(armGroupR);
            santaRightArm = armGroupR;

            sleighGroup.add(santaBody);


            // --- 3. Detailed Reindeer ---
            function createReindeer(x, z, isRudolph = false) {
                const deer = new THREE.Group(); 
                const furMat = new THREE.MeshStandardMaterial({ color: 0x855E42, roughness: 0.9 }); 
                const hoofMat = new THREE.MeshStandardMaterial({ color: 0x1f2937 });

                // Body (Rounded)
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.28, 1.1, 8), furMat); 
                body.rotation.x = Math.PI / 2; body.position.y = 0.8; deer.add(body);
                
                // Neck
                const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.22, 0.5), furMat); 
                neck.position.set(0, 1.1, 0.5); neck.rotation.x = -Math.PI/4; deer.add(neck);
                
                // Head
                const headGroup = new THREE.Group();
                const headMain = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.24, 0.35), furMat);
                headGroup.add(headMain);
                const snout = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.15, 0.2), furMat);
                snout.position.set(0, -0.05, 0.25); headGroup.add(snout);
                
                // Nose
                const noseColor = isRudolph ? 0xff0000 : 0x000000;
                const noseEmissive = isRudolph ? 0xff0000 : 0x000000;
                const nose = new THREE.Mesh(new THREE.SphereGeometry(0.06), new THREE.MeshStandardMaterial({color: noseColor, emissive: noseEmissive, emissiveIntensity: isRudolph ? 2 : 0}));
                nose.position.set(0, 0, 0.35); headGroup.add(nose);

                // Antlers
                const antlerMat = new THREE.MeshStandardMaterial({ color: 0xfef3c7 });
                function createAntler(side) {
                    const ag = new THREE.Group();
                    const main = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.6), antlerMat);
                    main.position.y = 0.3; ag.add(main);
                    const branch = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.3), antlerMat);
                    branch.position.set(0, 0.2, 0.1); branch.rotation.x = Math.PI/4; ag.add(branch);
                    ag.position.set(side * 0.1, 0.15, -0.05);
                    ag.rotation.z = side * 0.3;
                    return ag;
                }
                headGroup.add(createAntler(1));
                headGroup.add(createAntler(-1));

                headGroup.position.set(0, 1.4, 0.7);
                deer.add(headGroup);
                reindeerHeads.push(headGroup); // Store for animation

                // Legs with Hooves
                function createLeg(ox, oz) {
                    const lGroup = new THREE.Group();
                    const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.05, 0.6), furMat);
                    leg.position.y = -0.3; lGroup.add(leg);
                    const hoof = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.12), hoofMat);
                    hoof.position.set(0, -0.6, 0.02); lGroup.add(hoof);
                    lGroup.position.set(ox, 0.8, oz);
                    return lGroup;
                }
                const l1 = createLeg(-0.15, 0.4); deer.add(l1);
                const l2 = createLeg(0.15, 0.4); deer.add(l2);
                const l3 = createLeg(-0.15, -0.4); deer.add(l3);
                const l4 = createLeg(0.15, -0.4); deer.add(l4);
                
                reindeerLegs.push(l1, l2, l3, l4); 
                deer.position.set(x, 0, z); 
                return deer;
            }

            const d1 = createReindeer(-0.6, 3.5); sleighGroup.add(d1); 
            const d2 = createReindeer(0.6, 3.5); sleighGroup.add(d2);
            const d3 = createReindeer(-0.6, 5.5); sleighGroup.add(d3); 
            const d4 = createReindeer(0.6, 5.5, true); sleighGroup.add(d4); // Rudolph in front

            // Reins (Lines connecting deer to sleigh)
            const reinMat = new THREE.LineBasicMaterial({ color: 0x5c2b2b });
            const reinGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 1, 1.2), 
                new THREE.Vector3(0, 1.2, 3.5),
                new THREE.Vector3(0, 1.2, 5.5)
            ]);
            const rein = new THREE.Line(reinGeo, reinMat); sleighGroup.add(rein);

            // Magical Aura Light
            const magicLight = new THREE.PointLight(0xffd700, 2, 20);
            magicLight.position.set(0, 2, 0);
            sleighGroup.add(magicLight);
            
            // Magical Glow Sphere
            const glowGeo = new THREE.SphereGeometry(4, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({ 
                color: 0xffd700, 
                transparent: true, 
                opacity: 0.1, 
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide
            });
            const glowMesh = new THREE.Mesh(glowGeo, glowMat);
            sleighGroup.add(glowMesh);

            santaGroup.add(sleighGroup); santaGroup.position.set(0, 6, 0); santaGroup.visible = false; santaGroup.scale.set(0,0,0); scene.add(santaGroup);
        }
        createSantaSystem();

        // --- 7. Snow ---
        const snowGeo = new THREE.BufferGeometry(); const snowCount = 2500; const posArray = new Float32Array(snowCount * 3); const velocityInfo = []; 
        for(let i=0; i<snowCount * 3; i+=3) {
            posArray[i] = (Math.random() - 0.5) * 100; posArray[i+1] = Math.random() * 60; posArray[i+2] = (Math.random() - 0.5) * 100;
            velocityInfo.push({ y: 0.05 + Math.random() * 0.1, x: (Math.random() - 0.5) * 0.02, z: (Math.random() - 0.5) * 0.02 });
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.25, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending });
        const snowSystem = new THREE.Points(snowGeo, snowMat); scene.add(snowSystem);

        // --- 8. Fireflies (Magic Dust) ---
        const fireflyGeo = new THREE.BufferGeometry(); const fireflyCount = 200; const fireflyPos = new Float32Array(fireflyCount * 3); const fireflyVel = [];
        for(let i=0; i<fireflyCount; i++) {
            fireflyPos[i*3] = (Math.random()-0.5) * 40; fireflyPos[i*3+1] = Math.random() * 10; fireflyPos[i*3+2] = (Math.random()-0.5) * 40;
            fireflyVel.push({ x: (Math.random()-0.5)*0.02, y: (Math.random()-0.5)*0.02, z: (Math.random()-0.5)*0.02 });
        }
        fireflyGeo.setAttribute('position', new THREE.BufferAttribute(fireflyPos, 3));
        const fireflyMat = new THREE.PointsMaterial({ color: 0xffd700, size: 0.15, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
        const fireflies = new THREE.Points(fireflyGeo, fireflyMat); scene.add(fireflies);

        let magicSparkles = [];
        function createMagicSparkles() {
            for(let i=0; i<50; i++) {
                 const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true }));
                 mesh.position.set(0, 1.5, 0); const theta = Math.random() * Math.PI * 2, phi = Math.random() * Math.PI, speed = 0.1 + Math.random() * 0.2;
                 mesh.userData.velocity = new THREE.Vector3(speed * Math.sin(phi) * Math.cos(theta), speed * Math.sin(phi) * Math.sin(theta), speed * Math.cos(phi));
                 scene.add(mesh); magicSparkles.push(mesh);
            }
        }

        // --- Camera & Animation ---
        camera.position.set(0, 8, 22); // Zoomed out slightly for better view 
        controls.update();

        let isTreeActive = true; let santaState = 'idle';
        let journeyStartPos = new THREE.Vector3(0, 60, -250); 
        let journeyTargetPos = new THREE.Vector3(0, 7.5, 0); 
        let journeyAlpha = 0;
        
        // Cinematic Path
        const santaPath = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, 60, -250),    // Start: High and far back
            new THREE.Vector3(-60, 45, -150),  // Control 1: Swoop Left
            new THREE.Vector3(60, 25, -60),    // Control 2: Swoop Right
            new THREE.Vector3(0, 7.5, 0)       // End: Arrival
        ]);

        // Sound Effect
        const santaSound = new Audio('https://actions.google.com/sounds/v1/cartoon/sleigh_bells.ogg');
        santaSound.volume = 0.6;

        // Warm Christmas BGM
        const bgm = new Audio('https://upload.wikimedia.org/wikipedia/commons/e/e1/Jingle_Bells_-_Kevin_MacLeod.ogg'); 
        bgm.loop = true;
        bgm.volume = 0.4;

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            // Twinkling Stars
            if (window.twinklingStars) {
                const sizes = window.twinklingStars.geometry.attributes.size; // If we had size attr
                // Just pulse opacity
                window.twinklingStars.material.opacity = 0.5 + Math.sin(time * 3) * 0.3;
            }

            // Breathing Lights
            breathingLights.forEach((light, i) => {
                light.intensity = 0.8 + Math.sin(time * 2 + i) * 0.3;
            });

            // Smoke
            for (let i = smokeParticles.length - 1; i >= 0; i--) {
                const p = smokeParticles[i]; p.mesh.position.y += 0.03; p.mesh.scale.multiplyScalar(1.01); p.mesh.material.opacity -= 0.005; p.life--;
                if(p.life <= 0 || p.mesh.material.opacity <= 0) { scene.remove(p.mesh); smokeParticles.splice(i, 1); }
            }
            // Snow with Wind
            const positions = snowSystem.geometry.attributes.position.array; 
            for(let i=0; i<positions.length; i+=3) {
                const idx = i/3; 
                positions[i+1] -= velocityInfo[idx].y; 
                // Add wind effect
                const wind = Math.sin(time * 0.5 + positions[i+1] * 0.05) * 0.05 + Math.sin(time * 2) * 0.01;
                positions[i] += wind + velocityInfo[idx].x;
                positions[i+2] += velocityInfo[idx].z;

                if (positions[i+1] < -2) { positions[i+1] = 50; positions[i] = (Math.random() - 0.5) * 100; positions[i+2] = (Math.random() - 0.5) * 100; }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;

            // Fireflies
            const ffPos = fireflies.geometry.attributes.position.array;
            for(let i=0; i<fireflyCount; i++) {
                ffPos[i*3] += fireflyVel[i].x; ffPos[i*3+1] += fireflyVel[i].y; ffPos[i*3+2] += fireflyVel[i].z;
                if(Math.abs(ffPos[i*3]) > 20) ffPos[i*3] *= -0.9; if(ffPos[i*3+1] < 0 || ffPos[i*3+1] > 10) fireflyVel[i].y *= -1; if(Math.abs(ffPos[i*3+2]) > 20) ffPos[i*3+2] *= -0.9;
            }
            fireflies.geometry.attributes.position.needsUpdate = true;

            // Walkers (Smarter Behavior & Physics)
            walkers.forEach(w => {
                // Celebration Mode
                if (santaState === 'arrived') {
                    // Face Santa
                    const dx = santaGroup.position.x - w.mesh.position.x;
                    const dz = santaGroup.position.z - w.mesh.position.z;
                    w.mesh.rotation.y = Math.atan2(dx, dz);
                    
                    // Jump for joy
                    w.mesh.position.y = Math.abs(Math.sin(time * 10 + w.walkTime)) * 0.5;
                    
                    // Wave hands
                    if (w.type === 'person') {
                        w.armL.rotation.z = Math.PI - 0.5 + Math.sin(time * 15) * 0.5;
                        w.armR.rotation.z = -Math.PI + 0.5 - Math.sin(time * 15) * 0.5;
                    } else if (w.type === 'dog') {
                        // Wag tail fast
                        w.tail.rotation.z = Math.sin(time * 20) * 1.0;
                        // Hop
                        w.mesh.position.y = Math.abs(Math.sin(time * 15)) * 0.3;
                    }
                    return; // Skip normal walking logic
                } else {
                    // Reset Y if not jumping
                    w.mesh.position.y = THREE.MathUtils.lerp(w.mesh.position.y, 0, 0.1);
                    
                    // Reset Arms Z (Fix for stuck arms)
                    if (w.type === 'person') {
                        w.armL.rotation.z = THREE.MathUtils.lerp(w.armL.rotation.z, 0.3, 0.1);
                        w.armR.rotation.z = THREE.MathUtils.lerp(w.armR.rotation.z, -0.3, 0.1);
                    }
                }

                if (!w.state) w.state = 'walking';
                if (!w.stateTimer) w.stateTimer = 0;

                if (w.state === 'walking') {
                    // Physics: Obstacle Avoidance
                    let avoidX = 0;
                    let avoidZ = 0;
                    let avoidanceActive = false;

                    obstacles.forEach(obs => {
                        const dx = w.mesh.position.x - obs.x;
                        const dz = w.mesh.position.z - obs.z;
                        const dist = Math.sqrt(dx*dx + dz*dz);
                        const minDist = obs.radius + 1.5; // 1.5 is walker radius buffer

                        if (dist < minDist) {
                            // Push away
                            const pushFactor = (minDist - dist) / minDist;
                            avoidX += (dx / dist) * pushFactor * 2.0; // Strong push
                            avoidZ += (dz / dist) * pushFactor * 2.0;
                            avoidanceActive = true;
                        }
                    });

                    if (avoidanceActive) {
                        // Steer away immediately
                        w.mesh.position.x += avoidX * 0.1;
                        w.mesh.position.z += avoidZ * 0.1;
                        
                        // Adjust angle to face away from obstacle
                        const currentDirX = Math.sin(w.angle);
                        const currentDirZ = Math.cos(w.angle);
                        
                        // If moving towards obstacle, turn
                        if ((currentDirX * avoidX + currentDirZ * avoidZ) < 0) {
                             w.targetAngle = Math.atan2(avoidX, avoidZ) + (Math.random() - 0.5);
                        }
                    }

                    if (Math.abs(w.angle - w.targetAngle) < 0.1) w.targetAngle = Math.random() * Math.PI * 2;
                    
                    // Smooth rotation
                    let diff = w.targetAngle - w.angle;
                    while (diff > Math.PI) diff -= Math.PI*2;
                    while (diff < -Math.PI) diff += Math.PI*2;
                    w.angle += diff * 0.02;
                    
                    w.mesh.position.x += Math.sin(w.angle) * w.speed; 
                    w.mesh.position.z += Math.cos(w.angle) * w.speed;
                    w.mesh.rotation.y = w.angle;
                    
                    if (w.mesh.position.length() > 45) { w.targetAngle = Math.atan2(-w.mesh.position.x, -w.mesh.position.z) + (Math.random()-0.5); }
                    
                    // Randomly stop to look at tree
                    if (Math.random() < 0.005) {
                        w.state = 'looking';
                        w.stateTimer = 100 + Math.random() * 200;
                    }
                } else if (w.state === 'looking') {
                    // Face 0,0,0 (Tree)
                    const targetRot = Math.atan2(-w.mesh.position.x, -w.mesh.position.z);
                    let diff = targetRot - w.angle;
                    while (diff > Math.PI) diff -= Math.PI*2;
                    while (diff < -Math.PI) diff += Math.PI*2;
                    w.angle += diff * 0.05;
                    w.mesh.rotation.y = w.angle;
                    
                    w.stateTimer--;
                    if (w.stateTimer <= 0) {
                        w.state = 'walking';
                        w.targetAngle = Math.random() * Math.PI * 2;
                    }
                }

                w.walkTime += 0.2;
                // Animate limbs only if walking
                if (w.state === 'walking') {
                    if (w.type === 'person') {
                        w.legL.rotation.x = Math.sin(w.walkTime) * 0.5; w.legR.rotation.x = Math.sin(w.walkTime + Math.PI) * 0.5;
                        w.armL.rotation.x = Math.sin(w.walkTime + Math.PI) * 0.5; w.armR.rotation.x = Math.sin(w.walkTime) * 0.5;
                    } else if (w.type === 'dog') {
                        w.legs.forEach((l, i) => l.rotation.x = Math.sin(w.walkTime + i) * 0.5); w.tail.rotation.z = Math.sin(w.walkTime * 2) * 0.5;
                    }
                } else {
                    // Reset limbs when stopped
                    if (w.type === 'person') {
                        w.legL.rotation.x = THREE.MathUtils.lerp(w.legL.rotation.x, 0, 0.1);
                        w.legR.rotation.x = THREE.MathUtils.lerp(w.legR.rotation.x, 0, 0.1);
                        w.armL.rotation.x = THREE.MathUtils.lerp(w.armL.rotation.x, 0, 0.1);
                        w.armR.rotation.x = THREE.MathUtils.lerp(w.armR.rotation.x, 0, 0.1);
                    }
                }
            });

            // Santa Logic
            if (santaState !== 'idle') {
                reindeerLegs.forEach((leg, i) => { leg.rotation.x = Math.sin(time * 20 + i) * 0.6; });
                
                // NEW: Reindeer Head Bobbing
                reindeerHeads.forEach((head, i) => {
                    head.rotation.x = Math.sin(time * 8 + i) * 0.2;
                });

                // NEW: Santa Body Bounce (Jolly)
                if (santaBody) {
                    santaBody.position.y = 1.0 + Math.sin(time * 10) * 0.05;
                }

                santaGroup.rotation.z = Math.sin(time * 3) * 0.05; santaGroup.rotation.x = Math.sin(time * 5) * 0.02;
            }

            if (santaState === 'traveling') {
                journeyAlpha += 0.0015; // Even slower for longer show
                
                // Spawn Magic Trail
                if (Math.random() < 0.3) {
                    const trailPos = santaGroup.position.clone();
                    trailPos.x += (Math.random() - 0.5) * 2;
                    trailPos.y += (Math.random() - 0.5) * 2;
                    trailPos.z += (Math.random() - 0.5) * 2;
                    
                    const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true }));
                    mesh.position.copy(trailPos);
                    mesh.userData.velocity = new THREE.Vector3(0, -0.05, 0); // Slowly fall
                    scene.add(mesh);
                    magicSparkles.push(mesh);
                }

                // Follow the curve
                const currentPos = santaPath.getPoint(journeyAlpha);
                const nextPos = santaPath.getPoint(Math.min(journeyAlpha + 0.01, 1));
                
                // Add "Life" - Bobbing
                currentPos.y += Math.sin(time * 5) * 0.5;

                santaGroup.position.copy(currentPos);
                
                // Calculate facing angle (for +Z facing model)
                const dx = nextPos.x - currentPos.x;
                const dz = nextPos.z - currentPos.z;
                const angle = Math.atan2(dx, dz);
                
                santaGroup.rotation.y = angle;
                
                // Bank into turn
                const tangent = santaPath.getTangent(journeyAlpha);
                santaGroup.rotation.z = -tangent.x * 0.5; // Bank left/right
                santaGroup.rotation.x = -tangent.y * 0.2; // Pitch up/down

                if (journeyAlpha >= 1) { santaState = 'turning'; journeyAlpha = 0; }
            } else if (santaState === 'turning') {
                journeyAlpha += 0.01; // Slower turn
                santaGroup.rotation.y = Math.min(journeyAlpha, 1) * (Math.PI / 2);
                if(journeyAlpha >= 1) {
                    santaState = 'waiting';
                    // SpotLight On
                    arrivalSpotlight.intensity = 3; // Brighter spotlight
                    setTimeout(() => {
                        santaState = 'arrived';
                        updateBubblePosition();
                        bubbleEl.style.opacity = '1'; bubbleEl.style.transform = 'translate(-50%, -100%) scale(1)';
                    }, 5000); // Longer wait for applause
                }
            } else if (santaState === 'arrived') {
                santaGroup.position.y = 7.5 + Math.sin(time * 3) * 0.2; 
                santaGroup.rotation.y = Math.PI / 2;
                // WAVING
                if(santaRightArm) {
                    santaRightArm.rotation.z = Math.PI - 0.5 + Math.sin(time * 8) * 0.3; 
                    santaRightArm.rotation.x = -0.5;
                }
                updateBubblePosition();
            } else if (santaState === 'turning_back') {
                // Rotate further to PI (Face back)
                journeyAlpha += 0.02;
                santaGroup.rotation.y = (Math.PI / 2) + Math.min(journeyAlpha, 1) * (Math.PI / 2);
                if(journeyAlpha >= 1) {
                    santaState = 'leaving';
                }
            } else if (santaState === 'leaving') {
                arrivalSpotlight.intensity *= 0.95; 
                santaGroup.position.z -= 0.8; 
                santaGroup.position.y += 0.3;
                
                // Bank left/right while flying away
                santaGroup.rotation.z = Math.sin(santaGroup.position.z * 0.05) * 0.2; 
                santaGroup.rotation.x = -0.2; // Pitch up slightly

                if(santaGroup.position.z < -200) { 
                    santaState = 'idle'; 
                    santaGroup.visible = false; 
                    isTreeActive = true; 
                    clickHint.style.display = 'block';
                    // Show Header Again
                    if(headerContainer) headerContainer.style.opacity = '1';
                }
            }

            if (magicSparkles.length > 0) {
                for (let i = magicSparkles.length - 1; i >= 0; i--) {
                    const obj = magicSparkles[i]; obj.position.add(obj.userData.velocity); obj.material.opacity -= 0.02;
                    if(obj.material.opacity <= 0) { scene.remove(obj); magicSparkles.splice(i, 1); }
                }
            }
            renderer.render(scene, camera);
        }
        animate();

        // --- Interaction ---
        const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();
        function updateBubblePosition() {
            if(santaState !== 'arrived') return;
            const pos = santaGroup.position.clone(); pos.y += 2.5; pos.project(camera);
            const x = (pos.x * .5 + .5) * window.innerWidth; const y = (-(pos.y * .5) + .5) * window.innerHeight;
            if(pos.z < 1) { bubbleEl.style.left = `${x}px`; bubbleEl.style.top = `${y}px`; }
        }
        function onMouseClick(event) {
            if(!isTreeActive) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            if (raycaster.intersectObjects(treeGroup.children).length > 0) triggerEvent();
        }
        window.addEventListener('click', onMouseClick);
        window.addEventListener('touchstart', (e) => {
             if(e.touches.length > 0) {
                 // Prevent default to stop scrolling/zooming while playing
                 // e.preventDefault(); // Optional: might block scrolling if needed
                 mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1; mouse.y = - (e.touches[0].clientY / window.innerHeight) * 2 + 1;
                 raycaster.setFromCamera(mouse, camera); if (raycaster.intersectObjects(treeGroup.children).length > 0) triggerEvent();
            }
        }, { passive: false });
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

        // Mobile Touch Support for UI
        const bubble = document.getElementById('thought-bubble');
        const windSound = document.getElementById('wind-sound');
        const chimeSound = document.getElementById('chime-sound');
        if(bubble) bubble.addEventListener('touchstart', (e) => { e.preventDefault(); santaClicked(); }, {passive: false});
        
        const closeBtn = document.querySelector('.btn-close');
        if(closeBtn) closeBtn.addEventListener('touchstart', (e) => { e.preventDefault(); closeWish(); }, {passive: false});

        const headerContainer = document.querySelector('.header-container');

        function triggerEvent() {
            if (!isTreeActive) return;
            isTreeActive = false; createMagicSparkles(); clickHint.style.display = 'none';
            
            // Hide Header
            if(headerContainer) headerContainer.style.opacity = '0';
            if(headerContainer) headerContainer.style.transition = 'opacity 1s';

            santaGroup.visible = true; santaGroup.position.copy(journeyStartPos); santaGroup.rotation.set(0,0,0); santaGroup.scale.set(1,1,1);
            journeyAlpha = 0; santaState = 'traveling';
            
            // Play Sound
            santaSound.currentTime = 0;
            santaSound.play().catch(e => console.log("Audio play failed:", e));
            
            // Play Wind Sound
            if(windSound) { windSound.volume = 0.5; windSound.play().catch(e => console.log("Wind play failed:", e)); }

            // Play BGM (YouTube)
            if(player && player.playVideo && !isMusicPlaying) {
                player.setVolume(30);
                player.playVideo();
                isMusicPlaying = true;
                musicBtn.innerHTML = '‚è∏ Pause Music';
            }
        }

        const wishes = [
            "‡∏Ñ‡∏£‡∏¥‡∏™‡∏ï‡πå‡∏°‡∏≤‡∏™‡∏ô‡∏µ‡πâ... ‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∏‡∏Ç‡πÇ‡∏≠‡∏ö‡∏Å‡∏≠‡∏î‡∏´‡∏±‡∏ß‡πÉ‡∏à‡πÄ‡∏ò‡∏≠‡πÑ‡∏ß‡πâ‡πÅ‡∏ô‡πà‡∏ô‡πÜ ‡∏ô‡∏∞ ‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏õ‡∏µ‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏≤‡∏à‡∏∞‡∏´‡∏ô‡∏±‡∏Å‡∏´‡∏ô‡∏≤‡πÅ‡∏Ñ‡πà‡πÑ‡∏´‡∏ô ‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏£‡∏π‡πâ‡∏ß‡πà‡∏≤‡πÄ‡∏ò‡∏≠‡πÄ‡∏Å‡πà‡∏á‡∏°‡∏≤‡∏Å‡πÅ‡∏•‡πâ‡∏ß‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏±‡∏ô‡∏°‡∏≤‡πÑ‡∏î‡πâ üéÑ‚ù§Ô∏è",
            "‡∏õ‡∏µ‡∏ô‡∏µ‡πâ‡πÄ‡∏ò‡∏≠‡πÄ‡∏ï‡∏¥‡∏ö‡πÇ‡∏ï‡∏Ç‡∏∂‡πâ‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏á‡∏î‡∏á‡∏≤‡∏°‡∏°‡∏≤‡∏Å‡πÄ‡∏•‡∏¢‡∏ô‡∏∞ ‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏µ‡πà‡∏≠‡∏î‡∏ó‡∏ô‡πÅ‡∏•‡∏∞‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏°‡∏≤‡∏ï‡∏•‡∏≠‡∏î ‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏õ‡∏µ‡∏´‡∏ô‡πâ‡∏≤‡πÉ‡∏à‡∏î‡∏µ‡∏Å‡∏±‡∏ö‡πÄ‡∏ò‡∏≠‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ò‡∏≠‡πÉ‡∏à‡∏î‡∏µ‡∏Å‡∏±‡∏ö‡πÇ‡∏•‡∏Å‡πÉ‡∏ö‡∏ô‡∏µ‡πâ ‚ú®",
            "‡∏£‡∏≠‡∏¢‡∏¢‡∏¥‡πâ‡∏°‡∏Ç‡∏≠‡∏á‡πÄ‡∏ò‡∏≠ ‡∏Ñ‡∏∑‡∏≠‡∏Ç‡∏≠‡∏á‡∏Ç‡∏ß‡∏±‡∏ç‡∏ó‡∏µ‡πà‡∏•‡πâ‡∏≥‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡πÇ‡∏•‡∏Å ‡∏≠‡∏¢‡πà‡∏≤‡∏•‡∏∑‡∏°‡∏¢‡∏¥‡πâ‡∏°‡πÉ‡∏´‡πâ‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡∏ö‡πà‡∏≠‡∏¢‡πÜ ‡∏ô‡∏∞ ‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏ó‡∏∏‡∏Å‡∏ß‡∏±‡∏ô‡πÄ‡∏ï‡πá‡∏°‡πÑ‡∏õ‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏£‡∏≤‡∏ß‡∏î‡∏µ‡πÜ üòä",
            "‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏õ‡∏µ‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏õ‡∏µ‡∏ó‡∏µ‡πà‡∏ó‡πâ‡∏≠‡∏á‡∏ü‡πâ‡∏≤‡∏™‡∏î‡πÉ‡∏™‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏ò‡∏≠‡πÄ‡∏™‡∏°‡∏≠ ‡πÅ‡∏°‡πâ‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ù‡∏ô‡∏ï‡∏Å ‡∏Å‡πá‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏°‡∏µ‡∏£‡πà‡∏°‡∏Ñ‡∏±‡∏ô‡πÉ‡∏´‡∏ç‡πà‡πÅ‡∏•‡∏∞‡∏Ñ‡∏ô‡∏Ç‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏à‡∏∞‡πÄ‡∏î‡∏¥‡∏ô‡πÑ‡∏õ‡∏Å‡∏±‡∏ö‡πÄ‡∏ò‡∏≠ üéÅ",
            "‡∏ó‡∏¥‡πâ‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏´‡∏ô‡∏∑‡πà‡∏≠‡∏¢‡∏•‡πâ‡∏≤‡πÅ‡∏•‡∏∞‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏®‡∏£‡πâ‡∏≤‡πÑ‡∏ß‡πâ‡∏ó‡∏µ‡πà‡∏õ‡∏µ‡πÄ‡∏Å‡πà‡∏≤ ‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏´‡∏±‡∏ß‡πÉ‡∏à‡πÉ‡∏´‡πâ‡∏ß‡πà‡∏≤‡∏á ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏±‡∏Å‡πÅ‡∏•‡∏∞‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∏‡∏Ç‡∏°‡∏´‡∏≤‡∏®‡∏≤‡∏•‡πÉ‡∏ô‡∏õ‡∏µ‡πÉ‡∏´‡∏°‡πà‡∏ô‡∏∞ üåü",
            "‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏°‡∏µ‡∏Ñ‡∏ô‡∏£‡∏±‡∏Å‡πÅ‡∏•‡∏∞‡πÄ‡∏≠‡πá‡∏ô‡∏î‡∏π‡πÄ‡∏ò‡∏≠ ‡πÉ‡∏ô‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ò‡∏≠‡πÄ‡∏™‡∏°‡∏≠‡∏ô‡∏∞ ‡∏Ñ‡∏ô‡πÄ‡∏Å‡πà‡∏á ‡πÄ‡∏ò‡∏≠‡∏™‡∏°‡∏Ñ‡∏ß‡∏£‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏±‡∏Å‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡πÇ‡∏•‡∏Å‡πÄ‡∏•‡∏¢‡∏•‡πà‡∏∞ üéÖ",
            "‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏Ç‡πâ‡∏≤‡∏á‡∏ô‡∏≠‡∏Å‡∏à‡∏∞‡∏´‡∏ô‡∏≤‡∏ß‡πÄ‡∏´‡∏ô‡πá‡∏ö‡πÅ‡∏Ñ‡πà‡πÑ‡∏´‡∏ô ‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡∏´‡∏±‡∏ß‡πÉ‡∏à‡∏Ç‡∏≠‡∏á‡πÄ‡∏ò‡∏≠‡∏≠‡∏ö‡∏≠‡∏∏‡πà‡∏ô‡πÄ‡∏™‡∏°‡∏≠ ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏≠‡πâ‡∏≠‡∏°‡∏Å‡∏≠‡∏î‡∏ó‡∏µ‡πà‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏£‡∏≠‡∏£‡∏±‡∏ö‡πÄ‡∏ò‡∏≠‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏•‡∏±‡∏ö‡∏ö‡πâ‡∏≤‡∏ô üî•",
            "‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ù‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ò‡∏≠‡∏ß‡∏≤‡∏î‡πÑ‡∏ß‡πâ ‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏•‡πá‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏´‡∏ç‡πà ‡∏Å‡∏•‡∏≤‡∏¢‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏£‡∏¥‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏ß‡∏¢‡∏á‡∏≤‡∏°‡∏¢‡∏¥‡πà‡∏á‡∏Å‡∏ß‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏à‡∏¥‡∏ô‡∏ï‡∏ô‡∏≤‡∏Å‡∏≤‡∏£‡πÑ‡∏ß‡πâ‡∏ô‡∏∞ üå†",
            "‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏£‡∏á ‡∏Å‡∏¥‡∏ô‡∏≠‡∏¥‡πà‡∏° ‡∏ô‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏ö‡∏ù‡∏±‡∏ô‡∏î‡∏µ ‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∏‡∏Ç‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡πÜ ‡∏ß‡∏±‡∏ô ‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡πÇ‡∏£‡∏Ñ‡∏†‡∏±‡∏¢‡πÑ‡∏Ç‡πâ‡πÄ‡∏à‡πá‡∏ö‡πÅ‡∏û‡πâ‡∏†‡∏±‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡πà‡∏≤‡∏£‡∏±‡∏Å‡∏Ç‡∏≠‡∏á‡πÄ‡∏ò‡∏≠‡πÑ‡∏õ‡πÄ‡∏•‡∏¢‡∏ô‡∏∞ üç¨",
            "Merry Christmas! ‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏õ‡∏≤‡∏è‡∏¥‡∏´‡∏≤‡∏£‡∏¥‡∏¢‡πå‡πÅ‡∏´‡πà‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∏‡∏Ç‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡∏Å‡∏±‡∏ö‡πÄ‡∏ò‡∏≠‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ‡πÅ‡∏•‡∏∞‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏ò‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏î‡πÉ‡∏™‡∏Ç‡∏≠‡∏á‡πÇ‡∏•‡∏Å‡πÉ‡∏ö‡∏ô‡∏µ‡πâ‡∏ï‡∏•‡∏≠‡∏î‡πÑ‡∏õ üéâ",
            "‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏õ‡∏µ‡πÉ‡∏´‡∏°‡πà‡∏ô‡∏µ‡πâ‡∏û‡∏≤‡πÄ‡∏ò‡∏≠‡πÑ‡∏õ‡∏û‡∏ö‡∏Å‡∏±‡∏ö‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡πÉ‡∏´‡∏°‡πà‡πÜ ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏´‡∏±‡∏ß‡πÉ‡∏à‡πÄ‡∏ò‡∏≠‡πÄ‡∏ï‡πâ‡∏ô‡πÅ‡∏£‡∏á‡∏î‡πâ‡∏ß‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∏‡∏Ç‡πÅ‡∏•‡∏∞‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏ß‡∏±‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ô‡∏∞ üöÄ",
            "‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏™‡∏á‡∏™‡∏ß‡πà‡∏≤‡∏á‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö‡∏Ñ‡∏ô‡∏£‡∏≠‡∏ö‡∏Ç‡πâ‡∏≤‡∏á‡πÄ‡∏™‡∏°‡∏≠‡∏°‡∏≤ ‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏á‡∏™‡∏ß‡πà‡∏≤‡∏á‡∏ô‡∏±‡πâ‡∏ô‡∏™‡∏∞‡∏ó‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏´‡∏≤‡πÄ‡∏ò‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏£‡πâ‡∏≠‡∏¢‡πÄ‡∏ó‡πà‡∏≤‡∏û‡∏±‡∏ô‡∏ó‡∏ß‡∏µ‡πÄ‡∏•‡∏¢‡∏ô‡∏∞ üí°",
            "‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏ò‡∏≠‡πÑ‡∏î‡πâ‡∏Ñ‡πâ‡∏ô‡∏û‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∏‡∏Ç‡πÉ‡∏ô‡∏™‡∏¥‡πà‡∏á‡πÄ‡∏•‡πá‡∏Å‡πÜ ‡∏ô‡πâ‡∏≠‡∏¢‡πÜ ‡∏£‡∏≠‡∏ö‡∏ï‡∏±‡∏ß ‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡πÅ‡∏ü‡πÅ‡∏Å‡πâ‡∏ß‡πÇ‡∏õ‡∏£‡∏î ‡∏´‡∏£‡∏∑‡∏≠‡∏ó‡πâ‡∏≠‡∏á‡∏ü‡πâ‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏¢‡πá‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏ß‡∏¢‡∏á‡∏≤‡∏° ‚òïüåÖ",
            "‡∏õ‡∏µ‡∏´‡∏ô‡πâ‡∏≤‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏õ‡∏µ‡∏ó‡∏µ‡πà‡πÄ‡∏ò‡∏≠‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏Å‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô ‡πÉ‡∏´‡πâ‡∏≠‡∏†‡∏±‡∏¢‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡∏á‡πà‡∏≤‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô ‡πÅ‡∏•‡∏∞‡∏†‡∏π‡∏°‡∏¥‡πÉ‡∏à‡πÉ‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡πÉ‡∏´‡πâ‡∏™‡∏∏‡∏î‡πÜ ‡πÑ‡∏õ‡πÄ‡∏•‡∏¢‡∏ô‡∏∞ üíñ",
            "‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡πÇ‡∏£‡∏¢‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏•‡∏µ‡∏ö‡∏Å‡∏∏‡∏´‡∏•‡∏≤‡∏ö ‡πÅ‡∏ï‡πà‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏´‡∏ô‡∏≤‡∏°‡∏ö‡πâ‡∏≤‡∏á ‡∏Å‡πá‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏ò‡∏≠‡∏°‡∏µ‡∏£‡∏≠‡∏á‡πÄ‡∏ó‡πâ‡∏≤‡∏ó‡∏µ‡πà‡πÅ‡∏Ç‡πá‡∏á‡πÅ‡∏£‡∏á‡∏û‡∏≠‡∏à‡∏∞‡∏Å‡πâ‡∏≤‡∏ß‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏±‡∏ô‡πÑ‡∏õ‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏™‡∏á‡πà‡∏≤‡∏á‡∏≤‡∏° üåπ",
            "‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏ò‡∏≠‡∏°‡∏µ‡∏û‡∏•‡∏±‡∏á‡πÉ‡∏à‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏°‡πÅ‡∏Ç‡πá‡∏á‡∏î‡∏±‡πà‡∏á‡∏†‡∏π‡∏ú‡∏≤ ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏≠‡πà‡∏≠‡∏ô‡πÇ‡∏¢‡∏ô‡∏î‡∏±‡πà‡∏á‡∏™‡∏≤‡∏¢‡∏ô‡πâ‡∏≥ ‡πÑ‡∏´‡∏•‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å‡∏≠‡∏∏‡∏õ‡∏™‡∏£‡∏£‡∏Ñ‡πÑ‡∏õ‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏£‡∏≤‡∏ö‡∏£‡∏∑‡πà‡∏ô‡∏ô‡∏∞ üèîÔ∏èüåä",
            "‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡πÄ‡∏ò‡∏≠‡∏à‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏î‡∏¥‡∏ô‡πÑ‡∏õ‡∏ó‡∏≤‡∏á‡πÑ‡∏´‡∏ô ‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á‡∏ô‡∏±‡πâ‡∏ô‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÅ‡∏•‡∏∞‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∏‡∏Ç‡∏£‡∏≠‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡πÄ‡∏ò‡∏≠‡∏≠‡∏¢‡∏π‡πà‡∏ô‡∏∞ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏ß‡πâ! üåà",
            "‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏õ‡∏µ‡πÉ‡∏´‡∏°‡πà‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏õ‡∏µ‡πÅ‡∏´‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡∏î‡∏µ ‡∏•‡∏∑‡∏°‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡πÅ‡∏¢‡πà‡πÜ ‡πÑ‡∏õ‡πÉ‡∏´‡πâ‡∏´‡∏°‡∏î ‡πÅ‡∏•‡πâ‡∏ß‡∏°‡∏≤‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ö‡∏ó‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏µ‡πà‡πÑ‡∏â‡πÑ‡∏•‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°‡∏Å‡∏±‡∏ô‡πÄ‡∏ñ‡∏≠‡∏∞! üìñ‚ú®",
            "‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏ò‡∏≠‡∏£‡∏≤‡∏¢‡∏•‡πâ‡∏≠‡∏°‡πÑ‡∏õ‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏±‡∏•‡∏¢‡∏≤‡∏ì‡∏°‡∏¥‡∏ï‡∏£‡∏ó‡∏µ‡πà‡∏î‡∏µ ‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏à‡∏∞‡∏´‡∏±‡∏ß‡πÄ‡∏£‡∏≤‡∏∞‡πÑ‡∏õ‡∏Å‡∏±‡∏ö‡πÄ‡∏ò‡∏≠‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≠‡∏¢‡∏ã‡∏±‡∏ö‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡πÉ‡∏´‡πâ‡πÄ‡∏ò‡∏≠‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡πà‡∏≠‡∏ô‡πÅ‡∏≠ ü§ùüíï",
            "‡∏™‡∏∏‡∏Ç‡∏™‡∏±‡∏ô‡∏ï‡πå‡∏ß‡∏±‡∏ô‡∏Ñ‡∏£‡∏¥‡∏™‡∏ï‡πå‡∏°‡∏≤‡∏™‡πÅ‡∏•‡∏∞‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏õ‡∏µ‡πÉ‡∏´‡∏°‡πà! ‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï‡∏Ç‡∏≠‡∏á‡πÄ‡∏ò‡∏≠‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏™‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏û‡∏•‡∏á‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÜ ‡∏ó‡∏µ‡πà‡∏ü‡∏±‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏´‡∏£‡πà‡∏Å‡πá‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∏‡∏Ç‡πÄ‡∏™‡∏°‡∏≠ üé∂üîî"
        ];
        function createUIParticles() {
            const rect = wishCard.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            for(let i=0; i<30; i++) {
                const p = document.createElement('div');
                p.classList.add('ui-particle');
                p.style.left = centerX + 'px';
                p.style.top = centerY + 'px';
                
                const angle = Math.random() * Math.PI * 2;
                const dist = 50 + Math.random() * 100;
                const tx = Math.cos(angle) * dist + 'px';
                const ty = Math.sin(angle) * dist + 'px';
                
                p.style.setProperty('--tx', tx);
                p.style.setProperty('--ty', ty);
                p.style.animationDelay = Math.random() * 0.2 + 's';
                
                document.getElementById('ui-layer').appendChild(p);
                setTimeout(() => p.remove(), 1000);
            }
        }

        function santaClicked() {
            wishText.innerText = wishes[Math.floor(Math.random() * wishes.length)];
            wishOverlay.classList.add('visible-el'); setTimeout(() => wishCard.classList.add('scale-in'), 50);
            createMagicSparkles(); // Burst stars on click
            createUIParticles(); // UI Sparkles
            if(chimeSound) { chimeSound.currentTime = 0; chimeSound.play().catch(e => console.log("Chime play failed:", e)); }
        }
        function closeWish() {
            wishCard.classList.remove('scale-in'); wishOverlay.classList.remove('visible-el');
            setTimeout(() => { bubbleEl.style.opacity = '0'; 
                // Trigger turn back first
                journeyAlpha = 0;
                santaState = 'turning_back'; 
                magicSparkles.forEach(obj => scene.remove(obj)); magicSparkles = []; }, 500);
        }
    </script>
</body>
</html>